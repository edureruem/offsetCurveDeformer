# νΉν— US8400455B2 μν•™μ  κ³µμ‹ λ¶„μ„

## π§® νΉν—μ ν•µμ‹¬ μν•™μ  μ•κ³ λ¦¬μ¦

### 1. λ°”μΈλ”© νμ΄μ¦ (Binding Phase) μν•™

#### 1.1 κ°€μ¥ κ°€κΉμ΄ μ  μ°ΎκΈ°
```
μ£Όμ–΄μ§„: λ¨λΈ ν¬μΈνΈ P_model, μν–¥ κ³΅μ„  C(u)
λ©ν‘: κ°€μ¥ κ°€κΉμ΄ κ³΅μ„  μƒμ μ κ³Ό νλΌλ―Έν„° μ°ΎκΈ°

μµμ†ν™” ν•¨μ: min |P_model - C(u)|Β²
κ²°κ³Ό: u_bind, P_influence = C(u_bind)
```

#### 1.2 μ¤ν”„μ…‹ λ²΅ν„° κ³„μ‚° (λ΅μ»¬ μΆν‘κ³„)
```
P_influence = C(u_bind)  // μν–¥ κ³΅μ„  μƒμ κ°€μ¥ κ°€κΉμ΄ μ 
T = C'(u_bind)           // νƒ„μ  νΈ λ²΅ν„° (μ •κ·ν™”)
N = κ³„μ‚°λ λ…Έλ§ λ²΅ν„°      // ν”„λ λ„· ν”„λ μ„μ λ…Έλ§
B = T Γ— N               // λ°”μ΄λ…Έλ§ λ²΅ν„°

// μ›”λ“ μΆν‘μ μ¤ν”„μ…‹ λ²΅ν„°
offset_world = P_model - P_influence

// λ΅μ»¬ μΆν‘κ³„λ΅ λ³€ν™ (μ΄κ²ƒμ΄ ν•µμ‹¬!)
offset_local.x = offset_world Β· T  // νƒ„μ  νΈ λ°©ν–¥ μ„±λ¶„
offset_local.y = offset_world Β· N  // λ…Έλ§ λ°©ν–¥ μ„±λ¶„  
offset_local.z = offset_world Β· B  // λ°”μ΄λ…Έλ§ λ°©ν–¥ μ„±λ¶„
```

#### 1.3 μ¤ν”„μ…‹ ν”„λ¦¬λ―Έν‹°λΈ μ €μ¥
```cpp
// νΉν—μ—μ„ μ €μ¥ν•λ” κ²ƒ (μµμ†ν•):
struct PatentOffsetPrimitive {
    int curve_index;           // μν–¥ κ³΅μ„  μΈλ±μ¤
    double u_bind;             // λ°”μΈλ“ μ‹μ μ κ³΅μ„  νλΌλ―Έν„°
    MVector offset_local;      // λ΅μ»¬ μΆν‘κ³„μ μ¤ν”„μ…‹ λ²΅ν„°
    double weight;             // μν–¥ κ°€μ¤‘μΉ
};
```

### 2. λ³€ν• νμ΄μ¦ (Deformation Phase) μν•™

#### 2.1 ν„μ¬ ν”„λ λ„· ν”„λ μ„ κ³„μ‚°
```
// μ• λ‹λ©”μ΄μ…μΌλ΅ κ³΅μ„ μ΄ λ³€ν•λ ν›„
P_current = C_current(u_bind)     // ν„μ¬ μν–¥ κ³΅μ„  μƒμ μ 
T_current = C'_current(u_bind)    // ν„μ¬ νƒ„μ  νΈ λ²΅ν„°
N_current = ν„μ¬ λ…Έλ§ λ²΅ν„°         // ν„μ¬ ν”„λ λ„· ν”„λ μ„μ λ…Έλ§
B_current = T_current Γ— N_current // ν„μ¬ λ°”μ΄λ…Έλ§ λ²΅ν„°
```

#### 2.2 λ³€ν•λ λ¨λΈ ν¬μΈνΈ κ³„μ‚° (νΉν—μ ν•µμ‹¬!)
```
// λ°”μΈλ“ μ‹μ μ λ΅μ»¬ μ¤ν”„μ…‹μ„ ν„μ¬ ν”„λ λ„· ν”„λ μ„μ— μ μ©
offset_world_current = 
    offset_local.x * T_current +
    offset_local.y * N_current +
    offset_local.z * B_current

// μƒλ΅μ΄ λ¨λΈ ν¬μΈνΈ μ„μΉ
P_model_new = P_current + offset_world_current * weight
```

### 3. ν”„λ λ„· ν”„λ μ„ κ³„μ‚° (Frenet Frame)

#### 3.1 νƒ„μ  νΈ λ²΅ν„°
```
T(u) = normalize(C'(u))  // κ³΅μ„ μ 1μ°¨ λ―Έλ¶„μ„ μ •κ·ν™”
```

#### 3.2 λ…Έλ§ λ²΅ν„° (μ—¬λ¬ λ°©λ²•)
```
λ°©λ²• 1 - κ³΅λ¥  κΈ°λ°:
N(u) = normalize(T'(u))  // νƒ„μ  νΈμ λ―Έλ¶„ (κ³΅λ¥  λ°©ν–¥)

λ°©λ²• 2 - μµμ† νμ „ (νΉν—μ—μ„ μ„ νΈ):
N(u) = μ΄μ „ ν”„λ μ„μΌλ΅λ¶€ν„° μµμ† νμ „μΌλ΅ κ³„μ‚°
```

#### 3.3 λ°”μ΄λ…Έλ§ λ²΅ν„°
```
B(u) = T(u) Γ— N(u)  // μ™Έμ μΌλ΅ κ³„μ‚°
```

### 4. κ°€μ¤‘μΉ κ³„μ‚°

#### 4.1 κ±°λ¦¬ κΈ°λ° κ°€μ¤‘μΉ
```
distance = |P_model - P_influence|
weight = 1.0 / (1.0 + distance / falloff_radius)
```

#### 4.2 λ‹¤μ¤‘ κ³΅μ„  μν–¥μ‹ μ •κ·ν™”
```
total_weight = Ξ£ weight_i
normalized_weight_i = weight_i / total_weight
```

## π― νΉν— μ•κ³ λ¦¬μ¦μ ν•µμ‹¬ μ¥μ 

### 1. λ©”λ¨λ¦¬ ν¨μ¨μ„±
- μ‹¤μ  μ¤ν”„μ…‹ κ³΅μ„ μ„ μƒμ„±ν•μ§€ μ•μ
- μν•™μ  νλΌλ―Έν„°λ§ μ €μ¥ (4κ° κ°’λ§!)
- κ³΅μ„  λ°μ΄ν„° μΊμ‹± λ¶ν•„μ”

### 2. μ •ν™•ν• λ³€ν•
- ν”„λ λ„· ν”„λ μ„ κΈ°λ°μΌλ΅ λ΅μ»¬ μΆν‘κ³„ μ μ§€
- κ³΅μ„ μ νμ „, μ¤μΌ€μΌ, λΉ„ν‹€λ¦Όμ— μ •ν™•ν λ°μ‘
- λ³Όλ¥¨ λ³΄μ΅΄ ν¨κ³Ό μλ™ λ‹¬μ„±

### 3. μ‹¤μ‹κ°„ μ²λ¦¬
- μ• λ‹λ©”μ΄μ… μ‹μ—λ§ κ³„μ‚° μν–‰
- λ°”μΈλ”© λ°μ΄ν„°λ” λ³€κ²½ μ—†μ
- GPU λ³‘λ ¬ν™” κ°€λ¥

## β ν„μ¬ κµ¬ν„κ³Όμ μ°¨μ΄μ 

### ν„μ¬ κµ¬ν„μ λ¬Έμ :
1. **κ³Όλ„ν• λ°μ΄ν„° μ €μ¥**: CV λ°°μ—΄, ν–‰λ ¬ λ°°μ—΄ λ“±
2. **λ³µμ΅ν• λ³€ν™**: λ¶ν•„μ”ν• λ§¤νΈλ¦­μ¤ μ—°μ‚°
3. **μΊμ‹± λ°©μ‹**: μ‹¤μ‹κ°„ κ³„μ‚° λ€μ‹  λ―Έλ¦¬ κ³„μ‚°ν•΄μ„ μ €μ¥
4. **λ©”λ¨λ¦¬ λ‚­λΉ„**: κ³΅μ„  λ°μ΄ν„°λ¥Ό μ¤‘λ³µ μ €μ¥

### νΉν— μ¤€μ κµ¬ν„:
1. **μµμ† λ°μ΄ν„°**: 4κ° κ°’λ§ μ €μ¥ (curve_index, u_bind, offset_local, weight)
2. **λ‹¨μ κ³„μ‚°**: λ²΅ν„° λ‚΄μ κ³Ό μ™Έμ λ§ μ‚¬μ©
3. **μ‹¤μ‹κ°„ λ°©μ‹**: ν•„μ”ν•  λ•λ§ Maya κ³΅μ„ μ—μ„ κ³„μ‚°
4. **λ©”λ¨λ¦¬ ν¨μ¨**: μν•™μ  νλΌλ―Έν„°λ§ μ €μ¥
